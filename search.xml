<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenCV的下载与环境搭建]]></title>
    <url>%2F%2Farticles%2FOpenCV%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[OpenCV OpenCV是个啥？OpenCV全称为Open Source Computer Vision Library,是由英特尔公司发起并参与研发的跨平台的计算机视觉库，并可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV用C++编写，主要接口也为C++,但保留了大量C语言接口。该库也有大量Python、Java、MATLAB/OCTAVE接口，目前也支持C#、Ch、Ruby。 OpenCV的下载OpenCV官网 下载相应的OpenCV版本，然后解压到自定义目录即可。 OpenCV环境变量设置找到自己的OpenCV解压路径，找到……\opencv\build\x64\vc14\bin,并复制本路径。右键我的电脑,选择属性,选择高级系统设置,选择环境变量。在系统变量中找到Path，点击编辑,将刚刚复制的路径粘贴进去。 OpenCV在Visual Studio 2017的环境配置打开VS2017并建立一个新的空项目，打开视图-&gt;属性管理器，会弹出属性管理器窗口，在属性管理器中打开Debug | x64,右键Microsoft.Cpp.x64.user文件，选择属性。 选择VC++目录,将包含目录修改为……opencv\build\include\opencv2 ……opencv\build\include\opencv ……opencv\build\include这三个目录，并将库目录改为……opencv\build\x64\vc14\lib。 选择链接器-&gt;输入,将附加依赖项改为对应版本的lib文件，这步修改是直接由键盘键入名字，这个文件的路径是……opencv\build\x64\vc14\lib，大家根据自己下载的OpenCV版本填写。]]></content>
      <tags>
        <tag>OpenCV</tag>
        <tag>帮助性文档</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[傻傻分不清系列(一)_C/C++中的const]]></title>
    <url>%2F%2Farticles%2F%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E7%9A%84const.html</url>
    <content type="text"><![CDATA[const在C/C++中的使用 初学C/C++时我就很头疼一些看似比较深奥的语法，比如count\static\define……等等，&gt;有的语法很碎很绕脑，不容易理解，而且可能老师讲的时候也不够细致（亦或没有老师自学）。因此想要开通一个关于C/C++语法中比较不容易理解的语法讲解，就叫&lt;傻傻分不清&gt;系列。如果我哪里有错误或者不够准确的地方，你可以发邮件给我 tpenbox@outlook.com ，当然你也可以加我的QQ：285999150. const会限定一个变量不允许被改变，使其具有静态效果。因为限制变量不得改变，因此它在一定程度上可以提高程序的安全性和可靠性。同时编译器会对const限定的变量进行类型安全检查，这也避免了一些稀奇古怪乱七八糟的bug出现。 常变量与常引用常变量用法：const[数据类型][变量名] = [值]; 此时你便定义了一个常变量。注意，由于const限制了变量不得改变，因此常变量必须在声明时进行初始化。在C标准下，常变量时全局变量，在C++下，要看其声明的位置。此时你不能改变它的值,否则编译器会报Error. 1234const int i = 100;int j = 200;i = 200; //错误i = j; //错误 此时可能知道#define的你就会问了，常变量和宏定义有什么区别呢？感觉它们的作用好像都一样啊！其实它们之间还是有些区别的。#define宏定义的本质是替换，比如 12345#define MAX 100int main()&#123; int i = MAX; return 0;&#125; 上述程序在编译的时候，由于其预处理了一个宏定义，编译器会把所有程序中出现的MAX替换成100,这种替换只是简单的展开替换，并不会进行类型安全检查。其次，#define不分配内存，出现多少次使用就会产生多少个拷贝，而const在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝。（拷贝的概念以后再讲吧QAQ） 常引用用法：const[数据类型]&amp;[变量名] = [变量名]; 注意，由于引用是一个变量的别名，它不能成为另一个变量的引用。因此它的方法和常变量一样。我们经常使用常引用在函数调用参数中，如果我们不愿意让函数修改参数的值，我们可以使用常引用 123void func(const double&amp; i)&#123; balabala....&#125; 常量与指针一般来说，常量指针和指针常量经常会使人分不太清楚 12const int* _a;//常量指针int* const _b;//指针常量 它们两个的区别在于：能否修改指针自己和能否修改指针所指向的对象。这里还要在插几句关于指针的知识，指针自己也是一个变量，只是指针这个变量里存的不是整数不是浮点数，而是存储着指向另一个变量的地址值 1234int a;int* _p;a = 2;//此时a的内存中存储的就是2_p = &amp;a;//此时p中存储的是a的地址 回归正题，我们可以列一个表格去区分指针常量和常量指针 能否修改指针自己 能否修改指针所指向的对象 常量指针 可以 不可以 指针常量 不可以 可以 对于常量指针来说，它可以通过改变自己去指向任何一块内存，但不能通过它来修改它指向 的内存 123456789int a = 5;int b = 5;const int* _p;_p = &amp;a;*_p = 0;//不合法，不能通过它来修改它指向的内存a = 0;//合法_p = &amp;b;//合法，可以通过改变自己去指向任何一块内存 指针常量则和常量指针相反，它不能通过改变自己去指向任何一块内存，但可以通过它来修改它指向的内存。 123456789int a = 5;int b = 5;int* const _p;_p = &amp;a;*_p = 0;//合法，可以通过它来修改它指向的内存a = 0;//合法p = &amp;b;//不合法，不能通过改变自己去指向任何一块内存 换而言之，const所修饰的东西不同，一般来说const修饰的是它左侧的东西，当const在最左边时，它便修饰右边的东西。 常量函数C++为了防止类中的数据被非法访问，因此出现了常量函数与非常量函数。可以说常量函数是对C++的一种拓展，它可以更好的维持C++的封装性。 [函数返回值类型][函数名]([参数列表])const; 常量函数 非常量函数 常量数据成员 可以调用 可以调用，但不能改变其值 非常量数据成员 不可以调用 可以调用 由上表可知，类内的常量函数无法调用类内的非常量数据成员。不管这些非常量数据成员是否在常量函数中被改变，常量函数都不能调用。 最后一点想说的const的实现是依赖于编译器的语法检查，在内存中并没有专门的区域存放常变量。因此我们其实可以通过绕开编译器的检查去修改常变量的值 123const int a = 100;int* _p = (int*)&amp;a; //需要显示转换，否则报错*_p = 200; 在gcc下，a的输出被改变为200。而在g++下，a的输出仍为100，但a对应地址的值其实已经被修改。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>帮助性文档</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>傻傻分不清</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言常用查询表]]></title>
    <url>%2F%2Farticles%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E8%A1%A8.html</url>
    <content type="text"><![CDATA[转义字符/数据类型与取值范围/格式字符/ASCII 转义字符 转移字符 字符 \’ ‘ \” “ \? ? \a 警告 \b 退格 \f 换页 \n 换行 \r 回车 \t 水平制表符 \v 垂直制表符 \o \oo \ooo(o为八进制数字) 表示八进制对应的ASCII字符 \xh(h为十六进制数字) 表示十六进制对应的ASCII字符 数据类型与取值范围 数据类型 字节 取值范围 int 2 -2^15~(2^15-1) int 4 -2^31~(2^31-1) unsigned int 2 0~(2^16-1) unsigned int 4 0~(2^32-1) short 2 -2^15~(2^15-1) unsigned short 2 0~(2^16-1) long 4 -2^31~(2^31-1) usigned long 4 0~(2^32-1) long long 8 -2^63~(2^63-1) usigned long long 4 0~(2^64-1) signed char 1 -128~127 unsigned char 1 0~255 float 4 0 &amp; 1.2*10^-38~3.4*10^38(绝对值/有效数字为6) double 8 0 &amp; 2.3*10^-308~1.7*10^308(绝对值/有效数字为15) long duble 16 0 &amp; 3.4*10^-4932~1.1*10^4932(绝对值/有效数字为19) 格式字符 格式字符 说明 d/i 带符号的十进制整数 o 无符号的八进制整数 x/X 无符号的十六进制整数 u 无符号的十进制整数 c 输出一个字符 s 输出字符串 f 小数形式输出单、双精度整数 e/E 以指数形式输出实数 ASCIIASCII控制字符 ASCII码 字符 解释 0 NUL 空字符 1 SOH 标题开始 2 STX 正文开始 3 ETX 正文结束 4 EOT 传输结束 5 ENQ 请求 6 ACK 收到通知 7 BEL 响铃 8 BS 退格 9 HT 水平制表符 10 LF 换行键 11 VT 垂直制表符 12 FF 换页键 13 CR 回车键 14 SO 不用切换 15 SI 启用切换 16 DLE 数据链路转义 17 DC1 设备控制1 18 DC2 设备控制2 19 DC3 设备控制3 20 DC4 设备控制4 21 NAK 拒绝接收 22 SYN 同步空闲 23 ETB 结束传输块 24 CAN 取消 25 EM 媒介结束 26 SUB 代替 27 ESC 换码(溢出) 28 FS 文件分隔符 29 GS 分组符 30 RS 记录分隔符 31 US 单元分隔符 32 空格 127 DEL 删除 ASCII打印字符 ASCII码 字符 33 ! 34 “ 35 # 36 $ 37 % 38 &amp; 39 ‘ 40 ( 41 ) 42 * 43 + 44 , 45 - 46 . 47 / 48 0 49 1 50 2 51 3 52 4 53 5 54 6 55 7 56 8 57 9 58 : 59 ; 60 &lt; 61 = 62 &gt; 63 ? 64 @ 65 A 66 B 67 C 68 D 69 E 70 F 71 G 72 H 73 I 74 J 75 K 76 L 77 M 78 N 79 O 80 P 81 Q 82 R 83 S 84 T 85 U 86 V 87 W 88 X 89 Y 90 Z 91 [ 92 \ 93 ] 94 ^ 95 _ 96 ‘ 97 a 98 b 99 c 100 d 101 e 102 f 103 g 104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o 112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w 120 x 121 y 122 z 123 { 125 } 126 ~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>帮助性文档</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++：类中的构造函数的调用顺序]]></title>
    <url>%2F%2Farticles%2F%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.html</url>
    <content type="text"><![CDATA[C++类中各种类构造函数的调用顺序汇总。 C++中，对象是由“底层向上”开始构造，因此在创建实例时，先执行基类的构造函数，再执行派生类的构造函数。 如果只是忘记规则需要翻阅，可以直接跳转到 总结 。如果想更清晰的明白，可以慢慢阅读全文。 单继承 如果遇到多级继承，构造函数会先调用父类的构造函数。如上图，A是B的父类，B是C的父类。此时如果创建类C的实例，就会先执行类A的构造函数，再执行类B的构造函数，最后执行类C的构造函数。如下图代码。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;class A&#123; public: A()&#123; cout&lt;&lt;"A OK"&lt;&lt;endl; &#125; &#125;;class B:public A&#123; public: B()&#123; cout&lt;&lt;"B OK"&lt;&lt;endl; &#125;&#125;; class C:public B&#123; public: C()&#123; cout&lt;&lt;"C OK"&lt;&lt;endl; &#125;&#125;;int main()&#123; A a; cout&lt;&lt;endl; B b; cout&lt;&lt;endl; C c; return 0;&#125; 上述代码的执行结果为 12345678A OKA OKB OKA OKB OKC OK 由此我们可以看出，再在多级继承中，C++会先调用最底层基类的构造函数，再一层一层的向上调用。 也可以这样理解，在创建类C的实例时，先调用其父类类B的构造函数，在调用类B构造函数时，则会先调用B类的父类类A的构造函数，由于类A没有父类，因此在执行完类A构造函数后，再执行类B构造函数，最后执行类C构造函数 多继承 如果一个派生类有两个父类时，构造函数也是由父类先构造，不过父类构造函数的调用顺序是由继承列表所规定的顺序所决定的。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;class A&#123; public: A()&#123; cout&lt;&lt;"A OK"&lt;&lt;endl; &#125; &#125;;class B&#123; public: B()&#123; cout&lt;&lt;"B OK"&lt;&lt;endl; &#125;&#125;; class C:public A,B&#123; //继承顺序 public: C()&#123; cout&lt;&lt;"C OK"&lt;&lt;endl; &#125;&#125;;int main()&#123; C c; return 0;&#125; 由于类C的继承顺序是A——B，所以先调用类A的构造函数，再调用类B的构造函数。程序运行结果如下。 123A OKB OKC OK 如果我们把类C的继承顺序修改成class C:public B,A,那么程序运行结果就会变成 123B OKA OKC OK 如果有遇到多继承的多级继承，则按照“先左后右，先父后子”的顺序执行类的构造函数。 虚继承当存在虚继承时，无论派生类的继承列表顺序为什么时，都先调用虚基类的构造函数。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class A&#123; public: A()&#123; cout&lt;&lt;"A OK"&lt;&lt;endl; &#125; &#125;;class B&#123; public: B()&#123; cout&lt;&lt;"B OK"&lt;&lt;endl; &#125;&#125;; class C:public virtual A&#123; public: C()&#123; cout&lt;&lt;"C OK"&lt;&lt;endl; &#125;&#125;;class D:public B,C&#123; public: D()&#123; cout&lt;&lt;"D OK"&lt;&lt;endl; &#125;&#125;;int main()&#123; D d; return 0;&#125; 如上图代码，虽然类D的继承顺序为先B后C，按上文“先左后右，先父后子”的顺序，应该先执行类B的构造函数，再执行类A的构造函数，但由于类C虚继承了类A，因此程序的运行结果如下 1234A OKB OKC OKD OK 优先执行虚基类的构造函数。 成员类如果在类中存在成员类，则成员类构造函数的执行先于类的构造函数，后于类的父类的构造函数。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; "A OK" &lt;&lt; endl; &#125;&#125;;class B &#123;public: B() &#123; cout &lt;&lt; "B OK" &lt;&lt; endl; &#125;&#125;;class C &#123;public: C() &#123; cout &lt;&lt; "C OK" &lt;&lt; endl; &#125;&#125;;class D :public B, C &#123;private: A a;public: D() &#123; cout &lt;&lt; "D OK" &lt;&lt; endl; &#125;&#125;;int main() &#123; D d; return 0;&#125; 上述程序中，类D中拥有一个类A的成员类，且拥有父类类B、类C，其程序运行结果为 1234B OKC OKA OKD OK 总结类构造函数的执行顺序为 1、虚基类构造函数执行2、基类构造函数按“先左后右，先父后子”的顺序执行3、成员类构造函数执行4、类自生构造函数执行 上述文章由我自己总结而成，难免存在一些错误、疏漏、无法理解的语句等问题，如果您发现错误、想要补充、有更好的表达方式，希望您可以给我发邮件，我的邮箱 tpenbox@outlook.com 本网站所有文章执行 CC BY-NC-SA 4.0 协议。希望您不要伤害熬夜好多为了维护网站且弱小无助寂寞的我。蟹蟹~！]]></content>
      <tags>
        <tag>帮助性文档</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string类常用函数汇总]]></title>
    <url>%2F%2Farticles%2Fstring%E7%B1%BB%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[string类常用函数汇总 头函数1#include&lt;string&gt; 构造函数12345678string s; //生成新的空字符串string s(string); //拷贝构造函数string s(string,int len); //将str内始于len的部分当作字符串的初值string s(string,int be,int len); //将str始于be且长度顶多len的部分作为字符串的初值string s(char*); //将C类型字符串作为s的初值string s(char*,int len); //将C类型字符串前len个字符作为字符串s的初值string s(int n,char c); //生成一个字符串，包含n个c字符s.~string(); //析构函数 C++字符串和C字符串的转换12str.data() //以字符数组的形式返回字符串内容(不含'\0')str.c_str() //以字符数组的形式返回字符串内容(含'\0') 获取字符串大小与容量1234str.size() //返回字符串长度str.length() //功能同上str.empty() //判断字符串是否为空str.max_size()//获得最多能包含的字符数 字符串中的元素存取12str[N] //获取字符串N位置的字符str.at(N) //功能同上 字符串的比较函数12 //string类之间支持 == 、&gt; 、&lt; 、&gt;= 、&lt;=str.compare() //待完善 更改字符串内容1234567891011//string支持 =、+、+=str.assign(str_2) //把str_2复制给strstr.assign(str_2,be,ed) //把str_2中区间为(be,ed]的元素赋值给strstr.assign(int N,char x) //把N个字符x赋值给strstr.clear() //清空字符串str.erase(be,ed) //删除区间为(be,ed]的元素str.erase(pos) //删除pos位置的元素（pos为迭代器）str.append(str_2) //增加str_2str.append(str_2,be,ed) //在str后增加str_2中区间为(be,ed]的元素str.append(int N,char x) //在str后增加N个字符xstr.insert(str_2,N) //在N位置后插入str_2]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>帮助性文档</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停电快乐]]></title>
    <url>%2F%2Farticles%2F%E5%81%9C%E7%94%B5%E5%BF%AB%E4%B9%90.html</url>
    <content type="text"><![CDATA[停电快乐]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++文件操作与文件流]]></title>
    <url>%2F%2Farticles%2FC-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%96%87%E4%BB%B6%E6%B5%81.html</url>
    <content type="text"><![CDATA[C++文件操作与文件流：较为详细的总结 头函数#include&lt;fstream&gt; 文件流类与文件流对象文件流类 文件流类 描述 ifstream 支持从磁盘文件向缓冲区输入 ofstream 支持从缓冲区向磁盘文件输入 fstream 支持对磁盘文件的输入输出 文件流对象定义一个文件流对象fstream fileclass;ofstream fileclass;ifstream fileclass; 文件的打开与关闭文件的打开调用成员函数openfilecalss.open(&quot;文件名&quot;，输入输出方式); 定义文件流对象时指定参数fstream fileclass(&quot;文件名&quot;，输入输出方式); 输入输出方式可以用按位与|的方式组合 输入输出方式设置值 作用 ios::in 以输入方式打开文件 ios::out 以输出方式创建并打开文件，若有此名文件则清空该文件 ios::app 以输入方式打开文件，写入的数据添加到文件末尾 ios::ate 打开一个已有文件，并将文件指针指向末尾 ios::trunc 存在文件则删除文件原内容，不存在则新建文件 ios::binary 以二进制方式打开文件，默认为ASCll方式打开 ios::nocreate 打开已有文件，若文件不存在则打开失败 ios::noreplace 文件若不存在则建立文件，文集存在则操作失败 文件的关闭调用成员函数关闭文件fileclass.close() 本操作实际是接触文件与文件流的关系 对ASCll文件的操作1-使用 &lt;&lt; 与 &gt;&gt; 即可2-使用put get getline 等成员函数 对二进制文件的操作读写使用成员函数读 : fileclass.read(字符指针，字节数)写 : fileclass.write(字符指针，字节数) 与文件指针有关的流成员函数 成员函数 作用 gcount() 得到最后一次输入所读入的字节数 tellg() 得到输入文件位置标记的当前位置 tellp() 得到输出文件位置标记的当前位置 seekg(文件位置) 将输入文件跳转到指定位置 seekg(位移量，参照位置) 将输入文件按参照位置和位移量移动 seekp(文件位置) 将输出文件跳转到指定位置 seekp(位移量，参照位置) 将输出文件按参照位置和位移量移动 参照位置 位置 ios::beg 文件开头（默认值） ios::cur 当前位置 ios::end 文件末尾]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>帮助性文档</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超详细：建立属于自己的网站]]></title>
    <url>%2F%2Farticles%2F%E5%BB%BA%E7%AB%8B%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99.html</url>
    <content type="text"><![CDATA[你准备好了吗？ 开始的开始首先我们需要一台电脑其次我们有些地方可能需要科学上网可能有的地方会卡住你，但是请不要轻言放弃可能你会面对一堆你看不懂的代码或者其他乱起八糟的东西，但是请不要知难而退希望你能享受当一个站长的时光未来的站长你准备好了吗？Let’s do it!! 我们的工具-git-Hexo-Github pages 下载并部署我们需要的工具下载首先，我们需要下载git和Node.js git官网 (注意，如果没有科学上网可能下载速度会比较慢) Node.js官网 windows安装git教程 (步骤可能比较繁琐，也会遇到命令框，但是加油看下去，一步一步来总会成功) windows安装Node.js教程 配置本地git安装好git后我们需要告诉git你是谁，所以我们右键桌面，打开Git Bash Here -执行 git conflg--global user.name&quot;Your Name&quot; Your Name处填写你的昵称-执行 git conflg--global user.email&quot;Your email&quot; Your email处填写你的邮箱 学习git的基础用法或许你想说，啥是git?????? git是一个分散式版本管理器。可能讲到这里你就蒙了，其实git就是一个文件的账本，你的每一次修改都会被寄到这个“账本”里，它会记住你每一次修改了文件里的什么、新增的文件、删除的文件。如果你哪天反悔了自己之前的修改，你可以通过git来翻旧账，恢复以前的版本。当然更重要的是它的分散管理，这点初学小白就不用知道太多了。 我相信你已经把git安装到你的电脑上了，我们来学习几个重要的git指令。 新建一个新的文件夹，在新的文件夹里按右键，点击那个“Git Bash Here” 欢迎来到黑洞洞的命令框。下面是一些我们常用的git指令 -cd xxxxx 这个指令可以让你打开在这个文件夹里叫xxxxx的子文件夹-git init 这个指令会在这个文件夹中初始化本地仓库，这样你的这个文件夹就有了git仓库(master是你主分支)-git add . 注意最后有个“.”，这个是将本地文件加到仓库里，就相当于开始记账了，“.”是代表这个文件夹里的所有文件，如果你只想添加一个文件，请把这个“.”换成那个文件的文件名 (这个文件需要在当前的文件夹内才可以) -git commit -m&quot;XXXXXX&quot; 这个指令通常和上面那个一起用，git add .只是记上了“这笔帐”，我们这条指令的目的是确定这笔账的存在，如果没有这个指令的话，你的文件修改不会被保存在git仓库里，XXXXXXX是你对这次修改文件的描述，建议一定要填写-git remote add origin git@github.com:YourUserName:YourRepositoriesName.git 这是将本地仓库链接到远程github仓库，如果不明白可以暂时跳过，下面还会再讲-git push -f origin master 将文件push到远程仓库，如果不明白可以暂时跳过，下面还会再讲 (注意，命令框里的复制粘贴不是Ctru+C和Ctru+V!!!) (git指令可能执行的比较慢，请一定等到git反馈并弹出彩色的显示你当前文件路径的语句后才能输入并执行下一条指令，如下图) 安装Hexo首先我们需要新建一个文件夹，叫什么随意，但是最好是英文的，这样会比较方便你在命令框下打开你的文件夹。为了方便我之后的讲解，我暂且觉得你的这个文件夹叫web 打开web文件夹，右键进入Git Bash -执行 npm install -g hexo cli 初始化框架-执行 hexo init blog 你会发现web文件夹下多了一个叫blog的文件夹-执行 cd blog 我们用git打开这个blog文件夹-执行 npm install 至此，我们拥有了一个网站的框架在blog文件夹中 我们来看一看blog文件夹里都有点什么-scaffolds 模板文件夹-source 资源文件夹，你网站的资源全部存放于此-theme 主题文件夹，hexo通过这个给你的主页设置主题-_config.yml 网站的配置信息，在此你可以设置一些参数-package.json 不用管它 （其实我也不知道干啥用的） 部署Hexo并生成\预览网页-执行 hexo new &quot;XXXXXXX&quot; 新建你的文章，XXXXXXX是你的文章名字，之后你可以在source/_posts里看到“XXXXXXX.md”的文件，你可以通过编辑这个文件来写你要发布的东西。 （.md文件就是Markdown的缩写，它是一种很方便的轻量化标记语言，它的具体用法和.txt基本一样，但是却可以产生更好的书写效果，更多md用法请看我关于Markdown的帮助文档，你可以在分类中找到它们） -执行 hexo g 这条指令会通过你blog文件夹下的文件建立静态网站-执行 hexo s 这条指令会启动本地服务器，在浏览器中输入 http://localhost:4000/ 就可以预览你建立的静态网站 (本地服务器不需要连接互联网就可以预览) 赶快通过上面的三个指令看看你网站的样子吧！ (git指令可能执行的比较慢，请一定等到git反馈并弹出彩色的显示你当前文件路径的语句后才能输入并执行下一条指令) (hexo s 指令执行后，你需要手动结束这条指令，结束方式是在命令行里输入Ctrl+C) 全球最大同性交友网站：Github什么是Github?GitHub是通过Git进行版本控制的软件源代码托管服务。相当于一个远程的git仓库，你甚至可以把任何文件上传github，让github成为你的云盘。同时Github还提供了一系列社交网络具有的功能，例如赞、关注、评论。用户可以通过复刻他人项目的形式参与开发，并可通过协作示意图来查看有多少开发者参与了开发并追踪最新的复刻版本。 你可以在Github上找到很多程序猿小哥哥。 我的Github主页 我们为什么使用Github？因为我们的网站需要一个服务器，Github pages可以给我们提供一个独立的、免费的、方便的服务器，因此我们需要使用Github。 注册Github账号Github官网 点击页面右上角 sign up 填写你的昵称，邮箱(务必保持邮箱可用)和密码。 最后一步是选择你的职业还有研究方向之类的，按照自己的情况选择就可以了。（实在不会选就随便选） 创建Github仓库在此之前，你需要去你的邮箱里通过Github给你发的链接来激活你的Github账号。 回到Github主页。 你需要把“YourGithubName”换为你Github的昵称。这时你就有了第一个Github仓库！ 将本地Git仓库链接到Github创建Git公钥打开”Git Bash” 1-执行 cd ~/.ssh(如果显示 ...No such file or directory 请跳过第2步直接执行第3步)2-执行 mkdir key_buckup mv id_isa* key_backup3-执行 ssh-keygen -t rsa -C &quot;your email&quot; 输出显示：&gt;Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;press enter&gt; 请直接回车！！ 4-输出显示：&gt;Enter passphrase (empty for no passphrase):&lt;enter a passphrase&gt;Enter same passphrase again:&lt;enter passphrase again&gt; 设置一个密码，这个密码在每次远程操作时都要输入。如果怕忘记密码或者嫌麻烦不想输密码，可以直接回车，不设置密码。 5-成功后显示：Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa. Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub. The key fingerprint is: ... ... 6-请根据显示的文件路径 /Users/your_user_directory/.ssh/id_rsa.pub 找到你的.ssh文件夹，用文本编辑器打开id_rsa.pub文件，复制所有内容。 7-进入 https://github.com/settings/keys 点击Add SSH Key,把复制的内容粘贴进去。 上传自己的网站我相信你已经在blog文件夹中尝试过使用hexo g和hexo s命令了。你会发现你的blog文件夹中多了一个public文件夹，这个文件夹就是我们要上传到服务器上的文件夹。 打开public文件夹，右键运行Git Bash。 -执行 git init-执行 git add .-执行 git commit -m&quot;XXXXXX&quot; 还记得 学习git的基础用法 中我说可以跳过的那两条命令吗？我们现在需要用它们了。 -执行 git remote add origin git@github.com:YourUserName:YourRepositoriesName.git（把YourUserName改成你的昵称，把YourRepositoriesName改成YourUserName.github.io）（这步的目的就是将你本地的Git仓库链接到Github上）（仓库与仓库的链接只用链接一次，以后上传文件就不用链接了） -执行 git push -f origin master（这步就是把本地git仓库里的东东上传到Github仓库里） 在浏览器中输入YourUserName.github.io就可以访问你的网站了。 以后以后修改自己的网站，先在本地修改.然后再blog文件夹下执行hexo g接着再public文件夹下进行git命令三步走 -执行 git add .-执行 git commit -m&quot;XXXXXX&quot; (把XXXXXXX改成你对这次修改的描述)-执行 git push -f origin master 这样你的Github仓库就和本地仓库同步了。 拥有一个自己的域名购买域名万网 首先你可以在万网上购买域名，万网是阿里旗下的，所以你可以使用淘宝账号登陆。 域名解析Dnspod 使用Dnspod来进行域名dns解析。 1-注册Dnspod账号2-进入主控台把你刚刚购买的域名添加进去 3-添加纪录记录值请写成 YourGithubName.github.io.,其余的按照我红框框中的去写 4-回到万网域名控制台,点击管理 5-修改DNS将DNS修改为f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 6-在本地public文件夹下建立CNAME文件，用文本编辑器打开，输入你购买的域名。使用git三步走推送至Github仓库。7-一般半个小时之后你就可以通过你的域名访问你的网站了！ 恭喜你成功的做出了自己的网站！！！！相关链接Hexo官网NexT主题]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>帮助性文档</tag>
        <tag>建站</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown-字体\颜色\大小]]></title>
    <url>%2F%2Farticles%2FMarkdown-%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E5%A4%A7%E5%B0%8F.html</url>
    <content type="text"><![CDATA[如何用markdown编辑文字字体、颜色与大小 字体1&lt;font face=&quot;字体&quot;&gt; XXXXXX &lt;/font&gt; 颜色 \ 大小1&lt;font color=16进制数 size=3 &gt; XXXXXXXX &lt;/font&gt; 默认大小为3。 颜色名 十六进制颜色值 例子 浅粉色 #FFB6C1 XXXXXXXX 粉红 #FFC0CB XXXXXXXX 猩红 #DC143C XXXXXXXX 淡紫色 #FFF0F5 XXXXXXXX 紫罗兰红色 #DB7093 XXXXXXXX 热情粉红 #FF69B4 XXXXXXXX 深粉色 #FF1493 XXXXXXXX 紫罗兰红色 #C71585 XXXXXXXX 兰花的紫色 #DA70D6 XXXXXXXX 蓟 #D8BFD8 XXXXXXXX 李子 #DDA0DD XXXXXXXX 紫罗兰 #EE82EE XXXXXXXX 洋红 #FF00FF XXXXXXXX 灯笼海棠 #FF00FF XXXXXXXX 深洋红色 #8B008B XXXXXXXX 紫色 #800080 XXXXXXXX 中兰花紫 #BA55D3 XXXXXXXX 深紫罗兰色 #9400D3 XXXXXXXX 深兰花紫 #9932CC XXXXXXXX 靛青 #4B0082 XXXXXXXX 深紫罗兰蓝 #8A2BE2 XXXXXXXX 中紫色 #9370DB XXXXXXXX 中板岩暗蓝灰 #7B68EE XXXXXXXX 板岩暗蓝灰 #6A5ACD XXXXXXXX 深岩暗蓝灰 #483D8B XXXXXXXX 薰衣草花淡紫 #E6E6FA XXXXXXXX 幽灵白 #F8F8FF XXXXXXXX 纯蓝 #0000FF XXXXXXXX 中蓝色 #0000CD XXXXXXXX 午夜蓝 #191970 XXXXXXXX 深蓝色 #00008B XXXXXXXX 海军蓝 #000080 XXXXXXXX 宝蓝 #4169E1 XXXXXXXX 矢车菊蓝 #6495ED XXXXXXXX 淡钢蓝 #B0C4DE XXXXXXXX 浅石板灰 #778899 XXXXXXXX 石板灰 #708090 XXXXXXXX 道奇蓝 #1E90FF XXXXXXXX 爱丽丝蓝 #F0F8FF XXXXXXXX 钢蓝 #4682B4 XXXXXXXX 淡蓝色 #87CEFA XXXXXXXX 天蓝色 #87CEEB XXXXXXXX 深天蓝 #00BFFF XXXXXXXX 淡蓝 #ADD8E6 XXXXXXXX 火药蓝 #B0E0E6 XXXXXXXX 军校蓝 #5F9EA0 XXXXXXXX 蔚蓝色 #F0FFFF XXXXXXXX 淡青色 #E1FFFF XXXXXXXX 苍白绿宝石 #AFEEEE XXXXXXXX 青色 #00FFFF XXXXXXXX 水绿色 #00FFFF XXXXXXXX 深绿宝石 #00CED1 XXXXXXXX 深石板灰 #2F4F4F XXXXXXXX 深青色 #008B8B XXXXXXXX 水鸭色 #008080 XXXXXXXX 中绿宝石 #48D1CC XXXXXXXX 浅海洋绿 #20B2AA XXXXXXXX 绿宝石 #40E0D0 XXXXXXXX 绿玉 #7FFFAA XXXXXXXX 中碧绿色 #00FA9A XXXXXXXX 中春天绿 #F5FFFA XXXXXXXX 薄荷奶油 #00FF7F XXXXXXXX 春天绿 #3CB371 XXXXXXXX 海洋绿 #2E8B57 XXXXXXXX 蜂蜜 #F0FFF0 XXXXXXXX 淡绿色 #90EE90 XXXXXXXX 苍白绿 #98FB98 XXXXXXXX 深海洋绿 #8FBC8F XXXXXXXX 酸橙绿 #32CD32 XXXXXXXX 酸橙色 #00FF00 XXXXXXXX 森林绿 #228B22 XXXXXXXX 纯绿 #008000 XXXXXXXX 深绿色 #006400 XXXXXXXX 查特酒绿 #7FFF00 XXXXXXXX 草坪绿 #7CFC00 XXXXXXXX 绿黄色 #ADFF2F XXXXXXXX 橄榄土褐色 #556B2F XXXXXXXX 米色 #6B8E23 XXXXXXXX 浅秋麒麟黄 #FAFAD2 XXXXXXXX 象牙色 #FFFFF0 XXXXXXXX 浅黄色 #FFFFE0 XXXXXXXX 纯黄 #FFFF00 XXXXXXXX 橄榄 #808000 XXXXXXXX 深卡其布 #BDB76B XXXXXXXX 柠檬薄纱 #FFFACD XXXXXXXX 灰秋麒麟 #EEE8AA XXXXXXXX 卡其布 #F0E68C XXXXXXXX 金 #FFD700 XXXXXXXX 玉米色 #FFF8DC XXXXXXXX 秋麒麟 #DAA520 XXXXXXXX 花白 #FFFAF0 XXXXXXXX 老饰带 #FDF5E6 XXXXXXXX 小麦色 #F5DEB3 XXXXXXXX 鹿皮鞋 #FFE4B5 XXXXXXXX 橙色 #FFA500 XXXXXXXX 番木瓜 #FFEFD5 XXXXXXXX 漂白杏仁 #FFEBCD XXXXXXXX Navajo白 #FFDEAD XXXXXXXX 古代白 #FAEBD7 XXXXXXXX 晒黑 #D2B48C XXXXXXXX 结实的树 #DEB887 XXXXXXXX 深橙色 #FF8C00 XXXXXXXX 亚麻布 #FAF0E6 XXXXXXXX 秘鲁 #CD853F XXXXXXXX 桃色 #FFDAB9 XXXXXXXX 沙棕色 #F4A460 XXXXXXXX 巧克力 #D2691E XXXXXXXX 马鞍棕色 #8B4513 XXXXXXXX 海贝壳 #FFF5EE XXXXXXXX 黄土赭色 #A0522D XXXXXXXX 浅鲜肉色 #FFA07A XXXXXXXX 珊瑚 #FF7F50 XXXXXXXX 橙红色 #FF4500 XXXXXXXX 深鲜肉色 #E9967A XXXXXXXX 番茄 #FF6347 XXXXXXXX 薄雾玫瑰 #FFE4E1 XXXXXXXX 鲜肉色 #FA8072 XXXXXXXX 雪 #FFFAFA XXXXXXXX 淡珊瑚色 #F08080 XXXXXXXX 玫瑰棕色 #BC8F8F XXXXXXXX 印度红 #CD5C5C XXXXXXXX 纯红 #FF0000 XXXXXXXX 棕色 #A52A2A XXXXXXXX 耐火砖 #B22222 XXXXXXXX 深红色 #8B0000 XXXXXXXX 栗色 #800000 XXXXXXXX 纯白 #FFFFFF XXXXXXXX 白烟 #F5F5F5 XXXXXXXX Gainsboro #DCDCDC XXXXXXXX 浅灰色 #D3D3D3 XXXXXXXX 银白色 #C0C0C0 XXXXXXXX 深灰色 #A9A9A9 XXXXXXXX 灰色 #808080 XXXXXXXX 暗淡灰 #696969 XXXXXXXX]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>帮助性文档</tag>
        <tag>建站</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
